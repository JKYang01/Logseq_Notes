- **Problem**: Binary Tree Right  Side View
  **Link**: [Binary tree right side view](https://leetcode.com/problems/binary-tree-right-side-view/description/)
  **Difficulty**: #Medium
	- Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return *the values of the nodes you can see ordered from top to bottom*.
	- **1. Core Concept & Complexity**
		- **Question**: What is the core technique for Binary tree right side view and its Time/Space complexity? #card
			- **Answer**:
				- **Concept**: using the search algorithm, the key is get the element level by level.
				- **Technique**:  BFS (deque and while loop) or DFS (recursive call)
				- **Time**: $O(n)$ because it loop through every elements
				- **Space**: $O(n)$
	- **2. Algorithm Logic (No Code)**
		- **Question**: Describe the logical steps to solve binary tree right side view without using code. #card
			- **Answer**:
				- Using DFS: initiate an empty list res out side of the dfs recursive function, the imput of dfs is the root and depth, the depth for calculating the depth of the recursion. if the node is None return None. else recursively check the right branch (right branch prior)  then left branch. Save the node when the depth is equal to the length of res. This algorithm add in the right node first if it exists, if it is not, it's gonna add in the node on the left side. It will not add additional left node because we already add in right node, the length of res is gonna exceeding the depth when continue add in left nodes. while right nodes
				- Using BFS: catch each level last  node by initialized the visable_node as None. init a double ended queue, while loop, inside while loop, loop through every elements in queue. current node is the leftpop of the deque. If current node is not none, set the visable node as current node. then append the left and right node to the deque.
				  The length of the loop is depends on the previous deque length aka current level element number.
	- **3. Python Implementation**
		- **Question**: Write the Python solution for Binary tree right side view. #card
			- **Answer**:
			  
			  Python
			  
			  <!----><!---->
			  
			  <!---->
			  
			  <!---->
			  
			  ```
			  # Paste your python code here
			  ## DFS solution
			  def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
			    res = []
			    def dfs(node,depth):
			      if not node:
			      	return None
			  
			      if depth==len(res):
			      	res.append(node.val)
			      dfs(node.right,depth+1)
			      dfs(node.left,depth+1)
			  
			    dfs(root,0)
			    return res
			    
			  ## BFS solution
			  def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
			    from collections import deque
			    res = []
			    if not root:
			    	return []
			    q = deque([root])
			    while len(q)>0:
			    	visable_node = None
			    	for _ in range(len(q)):
			        cur = q.popleft()
			        if cur:
			          visable_node = cur
			          q.append(cur.left)
			          q.append(cur.right)
			    	if visable_node:
			    		res.append(visable_node.val)
			    return res
			  ```