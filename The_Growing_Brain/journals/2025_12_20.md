- **Problem**: [[linked lists]] 
  collapsed:: true
  **Link**:  [Design Linked List](https://leetcode.com/problems/design-linked-list/description/)
  **Difficulty**: #Medium
	- **1. Core Concept & Complexity**
		- **Question**: What is the core technique for[[linked lists]] and its Time/Space complexity? #card
		  card-last-interval:: -1
		  card-repeats:: 1
		  card-ease-factor:: 2.5
		  card-next-schedule:: 2025-12-27T05:00:00.000Z
		  card-last-reviewed:: 2025-12-26T07:30:19.930Z
		  card-last-score:: 1
			- **Answer**:
				- **Concept**: [[linked lists]]
				- **Technique**:  use loop to traverse the linked list
				- **Time**: $O(n)$ because it needs to look through all the elements on the linked list o find the position
				- **Space**: $O(n)$  Requires traversing the list to find the specific position. 
				  The most optimum case is O(1) if insert or delete at the head.
	- **2. Algorithm (no code)**
	- **3. Python Implementation**
		- **Question**: Write the Python solution for [[linked lists]] operations . #card
			- **Answer**:
			  
			  Python
			  
			  <!----><!---->
			  
			  ```
			  
			  ## Doubly linked
			  
			  class Node:
			      def __init__(self,val):
			          self.val = val 
			          self.prev = None
			          self.next = None
			  
			  class MyLinkedList:
			      def __init__(self):
			          self.head = Node(-1) # dummy head
			          self.tail = Node(-1) # dummy tail
			          # let those two dummy nodes point to each other, the list is empty
			          self.head.next = self.tail
			          self.tail.prev = self.head 
			          
			      def get(self, index: int) -> int:
			          cur = self.head.next
			          # loop over when cur is None that means it's out of the list
			          while cur and index > 0:
			              cur = cur.next
			              index-=1
			          if cur and index==0:
			              return cur.val
			          return -1
			  
			      def addAtHead(self, val: int) -> None:
			          # add in head *before the real head, but after the dummy head
			          new_head = Node(val)
			          new_head.next = self.head.next
			          self.head.next.prev = new_head
			          self.head.next = new_head
			          new_head.prev = self.head
			  
			      def addAtTail(self, val: int) -> None:
			          prev,node,next = self.tail.prev, Node(val), self.tail
			          prev.next = node
			          next.prev = node
			          node.prev = prev
			          node.next = next
			         
			      def addAtIndex(self, index: int, val: int) -> None:
			          # add in a new node *before the index position of the linked list
			          cur = self.head.next
			          while index > 0 and cur:
			              cur = cur.next 
			              index -=1
			          if cur and index==0: 
			              prev,node,next = cur.prev,Node(val),cur
			              prev.next = node
			              cur.prev = node
			              node.next = cur
			              node.prev = prev
			  
			      def deleteAtIndex(self, index: int) -> None:
			          cur = self.head.next
			          while index >0 and cur:
			              cur = cur.next
			              index -= 1 
			          if cur and cur!=self.tail and index == 0: # if it is as the dummy tail it's out of the capacity
			              prev,next = cur.prev,cur.next
			              prev.next = next
			              next.prev = prev
			  
			  
			  ## Single linked list
			  
			  class ListNode:
			      def __init__(self, val: int):
			          self.val = val
			          self.next = None
			  
			  class MyLinkedList:
			      def __init__(self):
			          self.head = ListNode(0)
			          self.size = 0
			  
			      def get(self, index: int) -> int:
			          if index >= self.size:
			              return -1
			          cur = self.head.next
			          for _ in range(index):
			              cur = cur.next
			          return cur.val
			  
			      def addAtHead(self, val: int) -> None:
			          node = ListNode(val)
			          node.next = self.head.next
			          self.head.next = node
			          self.size += 1
			  
			      def addAtTail(self, val: int) -> None:
			          node = ListNode(val)
			          cur = self.head
			          while cur.next:
			              cur = cur.next
			          cur.next = node
			          self.size += 1
			  
			      def addAtIndex(self, index: int, val: int) -> None:
			          if index > self.size:
			              return 
			          cur = self.head
			          for _ in range(index):
			              cur = cur.next
			          new_node = ListNode(val)
			          new_node.next = cur.next
			          cur.next = new_node
			          self.size +=1 
			  
			      def deleteAtIndex(self, index: int) -> None:
			          if index >= self.size:
			              return
			          cur = self.head
			          for _ in range(index):
			              cur = cur.next
			          cur.next = cur.next.next
			          self.size -= 1
			  ```
- TBD