- **Problem**: [[Back Tracking]]
  **Link**: [N-Queens](https://leetcode.com/problems/n-queens/?envType=problem-list-v2&envId=backtracking), [Path Sum](https://neetcode.io/problems/path-sum/question), [Subsets](https://neetcode.io/problems/subsets/question?list=neetcode150)
  **Difficulty**: #Easy | #Medium | #Hard
	- **1. Core Concept & Complexity**
		- **Question**: What is the core technique for [[Back Tracking]] and its Time/Space complexity? #card
			- **Answer**:
				- **Concept**: Backtracking is ==an algorithmic technique for solving problems by trying to **build a solution incrementally**, one piece at a time==. It uses a "trial and error" approach: if a partial solution leads to a dead end or violates problem constraints, the algorithm **undoes the last choice** (backtracks) and tries a different option.
				- **Technique**: Recursion, sets
				- **Time**: $O(n)$ because it go through every elements
				- **Space**: $O(n)$
	- **2. Algorithm Logic (No Code)**
		- **Question**: Describe the logical steps to solve [N-Qeens] without using code. #card
			- **Answer**:
				- Step 1: Initialize the nxn board, empity sets for saving queens attacking range for checking each step when put down the queen to see if the queen is in the scope of attacking range of the last queen.
				- Step 2: build a recursion function, In the recursion we set the return condition which is the recursion depth is equal to the number of rows, save the result and return 
				  For each recursion step we loop through each column in the current row and put down the queen.
				- Step 3: If the queen is in any of the attacking range of other queen that is on the board, we don't put the queen there and continue loop. 
				  if it does not in any of the queen's attacking rang, put the queen at that spot which is board[r][c], and save its attacking range to the sets.
				- Step 4: **Then we go to the next row by calling the recursion function with r+1 as input** If it went to the dead end (which trigger the function return) or succeed (which also trigger the function return )
				- Step 5: When the function returns (whether it is success  return or dead end trigger return), we remove the queen and remove all the attacking range records on the board.
	- **3. Python Implementation**
		- **Question**: Write the Python solution for [[(Topic Name)]]. #card
			- **Answer**:
			  
			  Python
			  
			  <!----><!---->
			  
			  <!---->
			  
			  <!---->
			  
			  ```
			  # Paste your python code here
			  class Solution:
			      def solveNQueens(self, n: int) -> List[List[str]]:
			          board = [["."]*n for _ in range(n)]
			          place_col = set()
			          place_neg = set()
			          place_pos = set()
			          results = []
			          def backtrack(r): # by row 
			              if r==n:
			                  copy = board[:]
			                  res = ["".join(c) for c in copy]
			                  results.append(res)
			                  return 
			  
			              for c in range(n): # loop on current row
			                  if c in place_col or r-c in place_neg or r+c in place_pos:
			                      continue
			                  
			                  board[r][c]='Q'
			                  place_col.add(c)
			                  place_neg.add(r-c)
			                  place_pos.add(r+c)
			                  backtrack(r+1) # go to next row 
			                  # if it return 
			                  board[r][c]='.'
			                  place_col.remove(c)
			                  place_neg.remove(r-c)
			                  place_pos.remove(r+c)
			          
			          backtrack(0)
			          return results
			  ```