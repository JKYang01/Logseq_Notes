- **Problem**: When to use DFS recursion and BFS iterator 
  **Link**: [neet code build tree: ] (https://neetcode.io/problems/binarySearchTree/question)
  **Difficulty**: #Medium
	- **1. Core Concept & Complexity**
		- **Question**: Build a Tree Map include insert, remove, find min, find max what are the Algorithm or technique that are used? #card
			- **Answer**:
				- insert, get, getmin, getmax: using while loop, init a cur node and then using while loop to loop through the elements
				- **The reason to choose recursion or while loop**:
				  Think about if this problem could be solve in a linear way rather than split to sub problem
					- 1. Following a single linear path
					- 2. **The iterative version is simpler/clearer*
					- 3. **want to avoid stack overflow** (very deep trees)
				- Use  **Recursion**  when:
				  1. Exploring multiple branches
				  **2. problem natually break into sub problems ** 
				  3.Need to process nodes in specific order (DFS traversals)
				  **4.work with tree structure modifications**
	- **2. Python Implementation**
		- **Question**: Write the Python solution for build Tree map class . #card
			- **Answer**:
			  
			  Python
			  
			  <!----><!---->
			  
			  <!---->
			  
			  <!---->
			  
			  ```
			  class TreeNode:
			      def __init__(self,key:int,val:int):
			          self.val = val
			          self.key = key
			          self.left = None
			          self.right = None
			  
			  
			  class TreeMap:
			      
			      def __init__(self):
			  
			          self.root = None
			  
			  
			      def insert(self, key: int, val: int) -> None:
			          new_node = TreeNode(key,val)
			          if self.root == None:
			              self.root = new_node
			              return 
			  
			          cur = self.root
			          while cur:
			              if key > cur.key:
			                  if cur.right == None:
			                      cur.right = new_node
			                      return
			                  cur = cur.right
			              elif key < cur.key:
			                  if cur.left == None:
			                      cur.left = new_node
			                      return 
			                  cur = cur.left
			              else:
			                  cur.val = val
			                  return 
			      
			      def get(self, key: int) -> int:
			          if self.root==None:
			              return -1
			          cur = self.root
			          while cur:
			              if cur.key==key:
			                  return cur.val
			              elif key > cur.key:
			                  cur = cur.right
			              else:
			                  cur = cur.left
			          return -1
			  
			      def getMin(self) -> int:
			          cur = self.root
			          if cur is None:
			              return -1
			          while cur and cur.left:
			              cur = cur.left
			          return cur.val
			  
			  
			      def getMax(self) -> int:
			          cur = self.root
			          if cur is None:
			              return -1
			          while cur and cur.right:
			              cur = cur.right
			          return cur.val
			  
			      
			      def _remove(self,cur:TreeNode, key:int):        
			          if self.root==None:
			              return None
			          if key > cur.key:
			              cur.right = self._remove(cur.right,key)
			          elif key < cur.key:
			              cur.left = self.remove(cur.left,key)
			          else:
			              if cur.left is None:
			                  return cur.right
			              elif cur.right is None:
			                  return cur.left
			              else: # move up the min node on right side as replace node
			                  minnode = cur.right
			                  while minnode and minnode.left:
			                      minnode = minnode.left
			                  cur.key = minnode.key
			                  cur.val = minnode.val
			                  cur.right = self._remove(cur.right, minnode.key)
			          
			          return cur
			  
			      def remove(self, key: int) -> None:
			          self.root = self._remove(self.root,key)
			  
			      def getInorderKeys(self) -> List[int]:
			          res = []
			          def dfs(root):
			              if not root:
			                  return 
			              dfs(root.left)
			              res.append(root.key)
			              dfs(root.right)
			          
			          dfs(self.root)
			          return res
			  
			  ```