- **Problem**: [[BST]]
  collapsed:: true
  **Link**: [insert BST node](https://neetcode.io/problems/insert-into-a-binary-search-tree/question?list=neetcode150)     [remove BST node](https://neetcode.io/problems/delete-node-in-a-bst/question?list=neetcode150)
  **Difficulty**:  #Medium
	- **1. Core Concept & Complexity**
		- **Question**: What is [[BST]] and its Time/Space complexity? #card
			- **Answer**:
				- **Concept**: Binary search tree is a kind of  [[Binary Tree]], which has two branches point to two nodes. The Binary search tree is special because it has a sorted property, which is every node in the left branch is smaller then the root and every node in the right branch is greater than root. Because of this sorted property we can design the algorithm to reach a optimized time and space complexity.
				- **Technique**: using recursive programming as [[DSF]]
				- **Time**: $O(logn)$ if the tree is balanced, because [[BST]] has sorted property every time we search on one side by comparing the value of current node and the value if the target. and don't have to loop through every elements. However, if  it is skewed tree, that would be the worst case, then the time complexity would be $O(n)$. or we could say the time and space complexity is O(h) h is the height of the tree.
				- **Space**: $O(logn)$ to $O(n)$ or we could say the time and space complexity is O(h) h is the height of the tree. Recursive call, binary search.
	- **2. Algorithm Logic (No Code)**
		- **Question**: Describe the logical steps to solve BST remove/delete without using code. #card
			- **Answer**:
				- Step 1: set the condition of case when the recursive function gonna return, the condition is when the root is none then return the root
				- Step 2: If the node only have one branch left or right, then recursively call function on the left or right branch. 
				  If the target target value < root.val  means it is on the left branch, so we set root.left equal to the result of removing the node from left branch, call function itself on left branch; 
				  if target value > root.val means it is on the right branch, then we set root.right as the result of removing the node from right branch, call function on right branch.
				- Step 3: if we find the node which value is equal to the target value, there are two conditions: 
				  1. the node has only one branch(not have left or not have right), then we make the subbranch to replace current node, which is return the existing subbranch.
				  2. the node has two branches. We find the minimum value on the right branch and make this node as the replacing root value, 
				  and then delete this node on the right branch by calling the function its self on the right branch with target value equal to the minimum right node value.
		- **3. Python Implementation**
			- **Question**: Write the Python solution for [[BST]] tager node remove . #card
				- **Answer**:
				  
				  Python
				  
				  <!----><!---->
				  
				  <!---->
				  
				  <!---->
				  
				  ```
				  # Definition for a binary tree node.
				  # class TreeNode:
				  #     def __init__(self, val=0, left=None, right=None):
				  #         self.val = val
				  #         self.left = left
				  #         self.right = right
				  class Solution:
				      
				      def find_right_min(self,cur):
				          while cur.left:
				              cur = cur.left
				          return cur
				  
				      def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
				  
				          if not root:
				                  return root
				              
				          if key > root.val:
				              root.right = self.deleteNode(root.right, key)
				          elif key < root.val:  # âœ“ Use elif here
				              root.left = self.deleteNode(root.left, key)
				          else:
				              # if only have right node
				              if not root.left:
				                  return root.right
				              # if only have left node
				              elif not root.right:
				                  return root.left 
				  
				              # if the node has two subnodes 
				              right_min = self.find_right_min(root.right)
				              root.val = right_min.val
				              root.right = self.deleteNode(root.right, root.val)
				  
				          return root
				  ```